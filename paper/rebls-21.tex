\documentclass[sigplan,screen]{acmart}

\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

\acmConference[REBLS '21]{REBLS '21: ACM Workshop on Reactive and Event-Based Languages and Systems}{June 03--05, 2018}{Chicago, IL}
\acmBooktitle{REBLS '21: ACM Workshop on Reactive and Event-Based Languages and Systems, June 03--05, 2018, Chicago, IL}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}

%\acmSubmissionID{123-A56-BU3}
%\citestyle{acmauthoryear}

\begin{document}

\title{Deterministic Distributed Interactive Applications}

\author{Francisco Sant'Anna}
\email{francisco@ime.uerj.br}
%\orcid{1234-5678-9012}
\affiliation{%
  \institution{Rio de Janeiro State University (UERJ)}
  \country{Brazil}
}

\author{Rodrigo Santos}
\email{rodrim.c@gmail.com}
\affiliation{%
  \institution{Microsoft}
  \country{Brazil}
}

\author{Noemi Rodriguez}
\email{noemi@inf.puc-rio.br}
\affiliation{%
  \institution{PUC-Rio}
  \country{Brazil}
}

%\renewcommand{\shortauthors}{Trovato and Tobin, et al.}

\begin{abstract}
A program is deterministic if re-execution with the same order of inputs always
leads to the same state.
It should even be possible to provide the same set of inputs to concurrent
instances in real time and observe identical behavior.
%
In this work, we guarantee real-time reproducibility in a distributed setting.
Mirrored instances of the same application are allowed to broadcast
asynchronous inputs and yet conform to identical behavior.
Collaborative networked applications, such as watch parties, document editing,
and video games can benefit of this approach.
%
Using a standard event-driven API to wait and generate events, programmers
write code as if the application executes in a single machine.
Our middleware intercepts event generation and synchronizes all instances so
that receipt is identically reproducible.
Not only distributed applications benefit of determinism but also development
and testing can be done in a single instance with the same guarantees.
\end{abstract}

\begin{comment}
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}
\ccsdesc[100]{Networks~Network reliability}
\end{comment}

\keywords{globally-asynchronous locally-synchronous, synchronous programming}

\maketitle

\section{Introduction}

Deterministic programs are easier to understand, test, and verify~\cite{det}.
Considering user interactions, a program is deterministic if re-execution with
the same order and timing of inputs always leads to the same state.
With such reproducibility property, multiple re-executions are
indistinguishable from one another.
Considering distribution, it should even be possible to provide the same set of
inputs to concurrent instances in real time and observe identical behavior.
In this work, our goal is to guarantee such real-time reproducibility property
in a distributed setting.
Mirrored instances of the same application should be allowed to broadcast
asynchronous inputs to each other and yet conform to identical behavior.

In the synchronous programming model~\cite{hipo}, a program executes in
locksteps (or logical ticks) as successive reactions to inputs provided by the
external environment.
The environment represents the user interacting with the application, and
inputs can be occasional events, such as a key press, or simply the passage of
time.
Since execution is guided from outside, the main advantage of the synchronous
model is that it can reproduce the exact behavior of a program by providing the
same sequence of inputs.
A fundamental requirement, known as the \emph{synchronous hypothesis}~\cite{hypo},
is that logical ticks are isolated from one another to preserve locksteps and
prevent concurrent reactions to inputs, which would break determinism.
This hypothesis is satisfied if computing reactions is faster than the rate of
external inputs.

An important concern is how to guarantee that isolated reactions are themselves
deterministic and sufficiently fast.
Synchronous languages~\cite{twelve} typically restrict the programming
primitives and/or perform static analysis to ensure these properties.
Since our solution involves standard event-driven APIs for generic programming
languages, we assume these properties are met informally with coding best
practices, such as avoiding stateful system calls and time-consuming loops.


  shows that ... but local
With distribution, communication timing is asynchronous because communication
latency takes a non-negligible time and breaks the synchronous hypothesis.


Synchronous: reactions run atomically and to comple-
tion on each line of execution, i.e., there’s no implicit
preemption or real parallelism.

Synchronous: reactions run atomically and to com-
pletion on each line of execution, i.e., there’s no
implicit preemption or real parallelism.

The synchronous execution model of Céu dictates
that reactions to input events are atomic and that in-
coming events are never lost, which we refer to as the
atomicity and responsiveness properties, respectively.

They rely on
the synchronous hypothesis which states that programs take no time to produce
outputs when reacting to inputs. The precise notion of time in these languages
is suitable for programming operations that should be performed respecting a
given timing constraint, which are common case in multimedia.

GALS...

Considering user interactions, a

 property
 with just two commands
 to broadcast
%
As limitations, the middleware relies on a centralized server and all instances
must be known and responsive during the entire execution.
In addition, reaction to events takes the maximum round-trip time considering
all clients, which can be intolerable for low-latency applications.

- not a equal apps, but the same app
    - one click in one is the same as in another, as if all xxx clicked together
Test locally in one instance is the same as N instances in M machines
What about in realtime
- a perfect mirror, cannot distinguish
- high-level vs low-leve events, semantic events


\section{Synchronous Programming}

- transparent mechanism
- all network communication
- simple API
- clear/sound properties to reason
- no extra programming
- ressaltar questão da interatividade, inclusive no título
  - single application, multiple views, may restrict events per node

- reproduceable, but not in real-time since the environments are asynchronous

Concurrent programs in non-deterministic languages are notoriously hard to prove correct and have led to well-known disasters.

\section{GALS Architecture}

The ``Globally-Asynchronous Locally-Synchronous Architecture (GALS)''
integrates multiple independent synchronous processes as a single distributed
application.

\section{Evaluation}

\section{Related Work}

Asynchronous languages and models:

Derflow: distributed deterministic dataflow programming for erlang
Erlang implements a message-passing execution model in which concurrent processes send each other messages asynchronously. This model is inherently non-deterministic: a process can receive messages sent by any process which knows its process identifier, leading to an exponential number of possible executions based on the number messages received. 
We propose a new execution model for Erlang, ''Deterministic Dataflow Programming'', based on a highly available, scalable single-assignment data store implemented on top of the riak\_core distributed systems framework.

Deterministic Actors
While actors provide a more disciplined model for concurrency than threads, their interactions, if not constrained, admit nondeterminism.
 We describe “reactors,” a new coordination model that combines ideas from several of the aforementioned approaches to enable determinism while preserving much of the style of actors.

Deterministic replay of distributed Java applications
Execution behavior of a Java application can be nondeterministic due to concurrent threads of execution, thread scheduling, and variable network delays. This nondeterminism in Java makes the understanding and debugging of multi-threaded distributed Java applications a difficult and a laborious process.
It is well accepted that providing deterministic replay of application execution is a key step towards programmer productivity and program under-standing.
Towards this goal, we developed a replay framework based on logical thread schedules and logical intervals.

Synchronous languages and models:

A Programming Model for Time-Synchronized Distributed Real-Time Systems
Discrete-event (DE) models are formal system specifications that have analysable deterministic behaviors. Using a global, consistent notion of time, DE components communicate via time-stamped events.
In this paper, we extend DE models with the capability of relating certain events to physical time.
Our technique relies on having a distributed common notion of time, known to some precision.




\section{Conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{rebls-21}

\end{document}
\endinput
